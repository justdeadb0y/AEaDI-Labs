class Node:   # Создаём класс Узел, чтобы в дальнейшем сформировать дерево, метод __init__ нужен для заполнения полей во время инициализации, а не через новую функцию set_value например
    def __init__(self, probability, char, leftnode=None, rightnode=None): 
        #self представляет экземпляр класса. Используя "self", мы можем получить доступ к атрибутам и методам класса в python. Он связывает атрибуты с заданными аргументами. 
        
        self.probability = probability  # Частота / вероятность
        self.char = char  # Символ
        self.left = leftnode # левый узел
        self.right = rightnode # правый узел
        self.code = '' # Для выбора пути по дереву 0 либо 1

    codes = dict() # Создаём словарик для кодов символов
    # Теперь напишем функцию, которая будет находить частоту встречающегося символа

    def calc_probs(inptdata): # На вход функции мы будем потдавать данные, которые мы считали из файла 
        chars = dict() # создаём словарик под численное кол-во частоты
        for elem in inptdata: # проходимся поэлементно по данным
            if chars.get(elem) == None: # через .get обращаемся к нашему словарю и сравниваем встречался ли символ до этого
                chars[elem] = 1 # если нет, значит он новый => его частота 1
            else:
                chars[elem] += 1 # иначе операцией += вычисляем новое значение
        return chars # итогом функции послужит возвращение словарика chars 
    # Теперь напишем функцию, которая будет подсчитывать код узла
    def calc_codes(node, value=''): # на вход передаём узел и пустое значение
        newvalue = value + str(node.code) # так будет формироваться новое значение путём конкатенации value и строки из кода узла
        if (node.left): # if node.left == true , то есть 1
            calc_codes(node.left, newvalue) # вызывается та же функция в которой мы сейчас, но уже передаются новые параметры
        if (node.right): # if node.right == true то есть 1
            calc_codes(node.right, newvalue) 
        if(not node.left and not node.right): # Если ((не (0/1 на левом узле)) и (не (0/1 на правом узле))) == true, то есть 1 это когда node.left and node.right оба равны 0 ((не 0) = 1) * ((не 0) = 1) == 1
            codes[node.char] = newvalue # Тогда мы заносим в словарик кодов для опр символов новое значение "код" символа состоящий из 0 и 1
        return codes # В результате функция вернёт словарик который мы объявляли до этого, но уже заполненный

        
#efile = open("example.txt", "r") # Открываем файл с примерным текстом
#inptdata = efile.read() #Читаем файл
#for i in range(0,len(string)):
#    print(ord(string[i]))